use crate::{image, instances::Instance, BevyVersion, Error, RustChannel};
use axum::{
    extract::Path,
    http::{header::CONTENT_TYPE, HeaderMap, HeaderName, HeaderValue},
    Json,
};
use serde::Deserialize;
use std::time::Instant;
use tracing::{error, info, instrument};

const COMMANDS: &[&str] = &["sh", "/playground/tools/build.sh"];

/// Extra code that is appended to the end of the user's code.
const EXTRA_CODE: &str = r#"
#[allow(unused_imports)]
use playground_lib::exports::*;
#[allow(unused_imports)]
use playground_lib::dbg;
"#;

/// Extra code that is appended to the end of the JS generated by wasm-bindgen.
const EXTRA_JS: &str = r#"
const imports = __wbg_get_imports();
__wbg_init_memory(imports);
const input = await wasm_blob.arrayBuffer();
const { instance, module } = await __wbg_load(input, imports);
ref_obj.wasm = instance.exports;
__wbg_finalize_init(instance, module);
"#;

#[derive(Deserialize)]
pub struct CompileRequest {
    code: String,
}

#[instrument(skip(payload))]
pub async fn compile(
    Path((version, channel)): Path<(BevyVersion, RustChannel)>,
    Json(payload): Json<CompileRequest>,
) -> Result<(HeaderMap, Vec<u8>), Error> {
    info!("Started");
    let start = Instant::now();

    let modified_code = modify_input_code(payload.code);
    let instance = Instance::new(image(version, channel), COMMANDS, &modified_code).await?;

    let output = instance.execute().await?;

    let code = output.status.code();
    let stderr = String::from_utf8(output.stderr)
        .unwrap_or_else(|_| String::from("Output contained invalid UTF8"));

    // Exit code 101 means the compiler failed to build the code due to it
    // being invalid Rust. This is a user error.
    if code == Some(101) {
        info!("User error: Completed in {:.2?}", start.elapsed());
        return Err(Error::BadCode { stderr });
    }

    if !output.status.success() {
        error!("Failed to build with exit code: {code:?}.\nStderr: {stderr}",);
        return Err(Error::Internal);
    }

    let wasm = instance.read("game_bg.wasm").await?;
    let js = instance.read_to_string("game.js").await?;
    let modified_js = modify_output_js(js);

    let wasm_length = wasm.len();
    let js_length = modified_js.len();

    let mut body = wasm;
    body.extend_from_slice(modified_js.as_bytes());
    body.append(&mut stderr.into_bytes());

    let mut headers = HeaderMap::new();
    headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/wasm"));
    headers.insert(
        HeaderName::from_static("wasm-content-length"),
        HeaderValue::from(wasm_length),
    );
    headers.insert(
        HeaderName::from_static("js-content-length"),
        HeaderValue::from(js_length),
    );

    info!("Success: Completed in {:.2?}", start.elapsed());
    Ok((headers, body))
}

/// Modifies the user's code to include the `playground_lib::Plugin` and the [`EXTRA_CODE`].
fn modify_input_code(code: String) -> String {
    let mut modified_code = code.replacen(
        "App::new()",
        "App::new().add_plugins(playground_lib::Plugin)",
        1,
    );
    modified_code.push_str(EXTRA_CODE);
    modified_code
}

fn modify_output_js(mut code: String) -> String {
    // The space after export is very important as some function names contain "export".
    code = code.replace("export ", "").replace("import.meta.url", "");
    // Remove the last two lines that break things.
    code.truncate(code.len() - 35);
    // Add the extra JS to make things work.
    code.push_str(EXTRA_JS);
    code
}
